## 정렬 문제 풀이 
시간복잡도가 O(nlogn)이 되는 정렬 알고리즘들(Merge, Quick, Heap)을 살펴보았습니다. 

이 알고리즘들을 Problem solving에서 사용해봅시다 ! 
### 1.[[leetcode] 1046. Last Stone Weight](https://leetcode.com/contest/weekly-contest-137/problems/last-stone-weight/)
#### 개요
우리는 **돌 수집가** 입니다. 

이 돌들을 이용해서 바위치기를 하려고 합니다. 

매 turn 마다 우리는 가장 무거운 돌 2개를 골라 서로 부딪힙니다. 

그러면 두 개의 돌이 사라지면서 **더 무거운 돌의 무게 - 가벼운 돌의 무게** 만큼의 무게를 가진 돌이 생겨납니다. 

만약에 **두 돌의 무게가 같다면 새로운 돌은 생겨나지 않습니다.**

게임은 돌이 1개 남았거나, 남은 돌이 없을 때 끝납니다. 

그렇다면 1개 남은 돌의 무게는 얼마일까요 ? 남아있는 돌이 없다면 0을 출력하세요 ^_^ 

#### 아이디어1
- 가장 무거운 돌 2개를 찾아야하므로 정렬 
- 가벼운 돌 사라지고, 무거운 돌의 무게가 감소함
- 무게가 같다면 돌 2개 사라짐.
``` cpp
#include <algorithm>

class Solution {
public:
    int lastStoneWeight(vector<int>& stones) {
        while(stones.size() > 1)
        {
            // turn마다 정렬을 수행하므로 
            sort(stones.begin(),stones.end());
            int last_val = stones.back();
            int second_last_val = stones[stones.size()-2];
            int diff = last_val - second_last_val;
            if(diff > 0)
            {
                stones[stones.size() -2] = diff;
                stones.pop_back();
            }
            else if(diff == 0)
            {
                stones.pop_back();
                stones.pop_back();
            }
        }
        return (stones.empty()? 0 : stones[0]);
    }
};
```
#### 아이디어2
- Priority Queue를 이용합니다. 
- 우선순위(Weight)가 가장 높은 2개의 돌을 꺼내고
- 무게의 차이만큼을 다시 queue에다 넣어줍니다. 
- 돌이 한 개 이하로 남을 때 까지 반복합니다.

Priority Queue의 Insert,Extract 연산은 **O(logN)**

``` cpp
class Solution {
public:
    int lastStoneWeight(vector<int>& stones) {
        priority_queue<int> pq(stones.begin(), stones.end()); 
        if (pq.empty()) return 0; 
        
        while (pq.size() > 1) {
            int mx1 = pq.top(); pq.pop(); 
            int mx2 = pq.top(); pq.pop(); 
            int dif = mx1 - mx2; 
            if (dif != 0) pq.push(dif); 
        }
        if (pq.empty()) return 0; 
        return pq.top(); 
    }
};
```

### 2.[[프로그래머스] K번째 수](https://programmers.co.kr/learn/courses/30/lessons/42748)
#### 개요 
주어진 배열의 n번째부터 m번째까지 잘라서 정렬한 뒤, 정렬된 배열에서 k번째 숫자를 찾습니다. 

~~n번째부터 m번째까지 잘라서 정렬~~ 한 것은 원 배열에 영향을 미치지 않습니다. 

#### 입출력 예시

|<center>array</center>|<center>commands</center>|<center>return</center>|
|:--------|:--------:|--------:|
|<center>[1, 5, 2, 6, 3, 7, 4]</center>|<center>[[2, 5, 3], [4, 4, 1], [1, 7, 3]]</center>|<center>[5, 6, 3]</center>|

입출력 예 설명

[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.

[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.

[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다.

#### 아이디어1 
정렬이 시작될 부분과 끝날 부분을 계산하여 전달해주었습니다. 

하지만 결과적으로 다음과 완전히 동일합니다.

sort(tmp_arr.begin()+commands[idx][0]-1,tmp_arr.begin()+commands[idx][1]);

```cpp
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> solution(vector<int> array, vector<vector<int>> commands) {
    vector<int> answer;
    for(int idx= 0; idx < commands.size();idx++)
    {
        vector <int> tmp_arr = array;
        sort(tmp_arr.begin()+commands[idx][0]-1,tmp_arr.end()-(tmp_arr.size()-commands[idx][1]));
        answer.push_back(tmp_arr[commands[idx][0]+commands[idx][2]-2]);
    }
    
    return answer;
}
```
조금 더 깔끔하게 수정하려면 auto 연산자를 사용하는 방법이 있습니다.  

```cpp
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> solution(vector<int> array, vector<vector<int>> commands) {
    vector<int> answer;
    for(auto command : commands)
    {
        vector <int> tmp_arr = array;
        sort(tmp_arr.begin()+command[0]-1,tmp_arr.begin()+command[1]);
        answer.push_back(tmp_arr[command[0]+command[2]-2]);
    }
    
    return answer;
}
```
#### 아이디어2 
~~segment tree를 이용한 풀이가 있던데, 내공을 더 쌓아오겠음 ㅠㅠ~~
